# T√™n t·ªáp: pages/02_backtest.py
import streamlit as st
import vectorbt as vbt
import pandas as pd
from datetime import datetime, timedelta
import ccxt
import yfinance as yf
import time
import pandas_ta as ta
import numpy as np

# --- C·∫§U H√åNH TRANG ---
st.set_page_config(page_title="Backtest Pro", page_icon="üìà", layout="wide")

# --- T√ôY CH·ªàNH CSS ---
st.markdown("""
    <style>
        .main { background-color: #0E1117; }
        .stMetric {
            background-color: #161B22;
            border: 1px solid #30363D;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        .block-container { padding-top: 2rem; }
    </style>
""", unsafe_allow_html=True)

# --- H√ÄM T·∫¢I D·ªÆ LI·ªÜU ---
@st.cache_data(ttl=600)
def load_price_data(asset_type, sym, timeframe, start_date, end_date):
    try:
        start_datetime = datetime.combine(start_date, datetime.min.time())
        end_datetime = datetime.combine(end_date, datetime.max.time())

        if asset_type == "Crypto":
            exchange = ccxt.kucoin()
            all_ohlcv = []
            since = int(start_datetime.timestamp() * 1000)
            end_ts = int(end_datetime.timestamp() * 1000)
            
            while since < end_ts:
                ohlcv = exchange.fetch_ohlcv(sym, timeframe, since=since, limit=1000)
                if not ohlcv: break
                all_ohlcv.extend(ohlcv)
                since = ohlcv[-1][0] + 1
                time.sleep(0.2)
            
            if not all_ohlcv: return None
            data = pd.DataFrame(all_ohlcv, columns=['timestamp', 'Open', 'High', 'Low', 'Close', 'Volume'])
            data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
            data.set_index('timestamp', inplace=True)
            data = data[~data.index.duplicated(keep='first')]
            data = data.loc[start_datetime:end_datetime]
        
        else: # Forex v√† Stocks
            yf_timeframe_map = {"1w": "1wk"}
            interval = yf_timeframe_map.get(timeframe, timeframe)
            data = yf.download(sym, start=start_date, end=end_date, interval=interval, progress=False, auto_adjust=True)
            if isinstance(data.columns, pd.MultiIndex):
                data.columns = data.columns.get_level_values(0)
            data.columns = [str(col).capitalize() for col in data.columns]

        if data.empty: return None
        return data
    except Exception as e:
        st.error(f"L·ªói khi t·∫£i d·ªØ li·ªáu: {e}")
        return None

# --- GIAO DI·ªÜN CH√çNH ---
st.title("üìà Dashboard Backtest Chuy√™n nghi·ªáp")

run_ml_backtest = st.session_state.get('run_ml_backtest', False)

# ==============================================================================
# CH·∫æ ƒê·ªò 1: KI·ªÇM CH·ª®NG CHI·∫æN L∆Ø·ª¢C ML
# ==============================================================================
if run_ml_backtest:
    st.success("**Ch·∫ø ƒë·ªô:** Ki·ªÉm ch·ª©ng Hi·ªáu su·∫•t Chi·∫øn l∆∞·ª£c ML.")
    info = st.session_state.get('ml_signal_info')
    
    if info and info.get('model'):
        asset = info['asset_class']
        symbol = info['symbol']
        tf = info['timeframe']
        model = info['model']
        # L·∫•y ng√†y th√°ng ƒë√£ l∆∞u t·ª´ trang T√≠n hi·ªáu ML
        start_date_bt = info['start_date']
        end_date_bt = info['end_date']
        
        with st.sidebar:
            st.header("Th√¥ng s·ªë t·ª´ T√≠n hi·ªáu ML")
            st.info(f"T√†i s·∫£n: **{asset}**\nM√£: **{symbol}**\nKhung TG: **{tf}**")
            st.write(f"**Th·ªùi gian ki·ªÉm ch·ª©ng:**")
            st.write(f"{start_date_bt.strftime('%Y-%m-%d')} ƒë·∫øn {end_date_bt.strftime('%Y-%m-%d')}")

            if st.button("Quay l·∫°i ch·∫ø ƒë·ªô MA-Cross"):
                st.session_state['run_ml_backtest'] = False
                st.rerun()

        with st.spinner("ƒêang t·∫£i d·ªØ li·ªáu v√† ki·ªÉm ch·ª©ng m√¥ h√¨nh ML..."):
            # S·ª≠ d·ª•ng ƒë√∫ng ng√†y th√°ng ƒë√£ l∆∞u ƒë·ªÉ t·∫£i d·ªØ li·ªáu
            full_data = load_price_data(asset, symbol, tf, start_date_bt, end_date_bt)

            if full_data is not None and not full_data.empty:
                df = full_data.copy()
                
                # T·∫°o l·∫°i ch√≠nh x√°c c√°c ƒë·∫∑c tr∆∞ng nh∆∞ l√∫c hu·∫•n luy·ªán
                df.ta.rsi(length=14, append=True)
                df.ta.sma(length=50, append=True)
                df.ta.sma(length=200, append=True)
                df.ta.adx(length=14, append=True)
                df.rename(columns={"RSI_14": "RSI", "SMA_50": "MA50", "SMA_200": "MA200", "ADX_14": "ADX"}, inplace=True)
                df['Price_vs_MA200'] = np.where(df['Close'] > df['MA200'], 1, -1)
                df.dropna(inplace=True)
                
                features = ['RSI', 'MA50', 'Price_vs_MA200', 'ADX']
                if all(f in df.columns for f in features):
                    predictions = model.predict(df[features])
                    entries = pd.Series(predictions, index=df.index).astype(bool)
                    exits = ~entries
                    
                    pf = vbt.Portfolio.from_signals(df['Close'], entries, exits, fees=0.001, freq=tf.upper().replace('M','T'))
                    stats = pf.stats()
                    
                    st.header("üìä K·∫øt qu·∫£ Backtest Chi·∫øn l∆∞·ª£c ML")
                    st.info(f"**Kho·∫£ng th·ªùi gian backtest:** {stats['Start'].strftime('%Y-%m-%d')} ƒë·∫øn {stats['End'].strftime('%Y-%m-%d')}")
                    st.subheader("C√°c ch·ªâ s·ªë Hi·ªáu su·∫•t")
                    col1, col2, col3, col4 = st.columns(4)
                    col1.metric("T·ªïng L·ª£i nhu·∫≠n [%]", f"{stats.get('Total Return [%]', 0):.2f}")
                    col2.metric("T·ª∑ l·ªá Th·∫Øng [%]", f"{stats.get('Win Rate [%]', 0):.2f}")
                    col3.metric("T·ª∑ l·ªá Sharpe", f"{stats.get('Sharpe Ratio', 0):.2f}")
                    col4.metric("S·ª•t gi·∫£m T·ªëi ƒëa [%]", f"{stats.get('Max Drawdown [%]', 0):.2f}")
                    st.divider()
                    st.subheader("Ph√¢n t√≠ch Chi ti·∫øt")
                    plot_col, stats_col = st.columns([2, 1])
                    with plot_col:
                        st.markdown("##### Bi·ªÉu ƒë·ªì V·ªën theo Th·ªùi gian")
                        fig = pf.plot()
                        st.plotly_chart(fig, use_container_width=True)
                    with stats_col:
                        st.markdown("##### Th·ªëng k√™ Chi ti·∫øt")
                        stats_display = stats.astype(str)
                        st.dataframe(stats_display)
                else:
                    st.error("D·ªØ li·ªáu kh√¥ng ƒë·ªß ƒë·ªÉ t·∫°o c√°c ƒë·∫∑c tr∆∞ng c·∫ßn thi·∫øt cho backtest.")
            else:
                st.warning("Kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu cho kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn.")
    else:
        st.error("Kh√¥ng t√¨m th·∫•y m√¥ h√¨nh ML. Vui l√≤ng quay l·∫°i trang 'T√≠n hi·ªáu ML' v√† hu·∫•n luy·ªán l·∫°i.")
        if st.button("Quay l·∫°i ch·∫ø ƒë·ªô MA-Cross"):
            st.session_state['run_ml_backtest'] = False
            st.rerun()
            
    if st.button("K·∫øt th√∫c ki·ªÉm ch·ª©ng ML"):
        st.session_state['run_ml_backtest'] = False
        st.rerun()

# ==============================================================================
# CH·∫æ ƒê·ªò 2: BACKTEST MA-CROSS M·∫∂C ƒê·ªäNH
# ==============================================================================
else:
    with st.sidebar:
        st.header("üéõÔ∏è C·∫•u h√¨nh Backtest MA-Cross")
        asset = st.selectbox("Lo·∫°i t√†i s·∫£n:", ["Crypto", "Forex", "Stocks"])
        if asset == "Crypto":
            symbol = st.text_input("C·∫∑p giao d·ªãch (CCXT):", "BTC/USDT")
            tf = st.selectbox("Khung th·ªùi gian:", ["1m", "5m", "15m", "30m", "1h", "4h", "1d", "1w"], index=4)
        else:
            default_symbol = "AAPL" if asset == "Stocks" else "EURUSD=X"
            symbol = st.text_input("M√£ (Yahoo Finance):", default_symbol)
            tf = st.selectbox("Khung th·ªùi gian:", ["1m", "5m", "15m", "30m", "1h", "4h", "1d", "1w"], index=6)
        st.subheader("Kho·∫£ng th·ªùi gian Backtest")
        end_date = st.date_input("Ng√†y k·∫øt th√∫c", value=datetime.now())
        start_date = st.date_input("Ng√†y b·∫Øt ƒë·∫ßu", value=end_date - timedelta(days=365))
        st.subheader("Th√¥ng s·ªë Chi·∫øn l∆∞·ª£c")
        fast_ma = st.slider("MA Nhanh", 5, 100, 20)
        slow_ma = st.slider("MA Ch·∫≠m", 20, 250, 50)
        st.subheader("Qu·∫£n l√Ω R·ªßi ro")
        initial_cash = st.number_input("V·ªën ban ƒë·∫ßu", min_value=100, value=10000, step=1000)
        sl_pct = st.slider("Stop Loss (%)", 0.5, 20.0, 2.0, 0.5)
        tp_pct = st.slider("Take Profit (%)", 0.5, 50.0, 4.0, 0.5)
        run_button = st.button("üöÄ Ch·∫°y Backtest", type="primary", use_container_width=True)

    if not run_button:
        st.info("üëà Vui l√≤ng c·∫•u h√¨nh c√°c tham s·ªë v√† nh·∫•n 'Ch·∫°y Backtest' ƒë·ªÉ xem k·∫øt qu·∫£.")

    if run_button:
        if start_date >= end_date:
            st.error("L·ªói: Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i tr∆∞·ªõc ng√†y k·∫øt th√∫c.")
        elif fast_ma >= slow_ma:
            st.error("L·ªói: MA Nhanh ph·∫£i nh·ªè h∆°n MA Ch·∫≠m.")
        else:
            with st.spinner("‚è≥ ƒêang t·∫£i d·ªØ li·ªáu v√† ch·∫°y backtest..."):
                warmup_candles = slow_ma
                time_delta_map = {'1m': timedelta(minutes=1), '5m': timedelta(minutes=5), '15m': timedelta(minutes=15), '30m': timedelta(minutes=30), '1h': timedelta(hours=1), '4h': timedelta(hours=4), '1d': timedelta(days=1), '1w': timedelta(weeks=1)}
                candle_duration = time_delta_map.get(tf, timedelta(days=1))
                estimated_warmup_duration = max(candle_duration * warmup_candles * 1.7, timedelta(days=1))
                data_start_date = start_date - estimated_warmup_duration
                
                full_price_data = load_price_data(asset, symbol, tf, data_start_date, end_date)
                
                if full_price_data is not None and not full_price_data.empty:
                    price = full_price_data['Close']
                    fast_ma_series = price.rolling(fast_ma).mean()
                    slow_ma_series = price.rolling(slow_ma).mean()
                    entries = fast_ma_series > slow_ma_series
                    exits = fast_ma_series < slow_ma_series
                    
                    backtest_price = price.loc[start_date:end_date]
                    backtest_entries = entries.loc[start_date:end_date]
                    backtest_exits = exits.loc[start_date:end_date]
                    
                    if backtest_price.empty:
                        st.error("Kh√¥ng c√≥ d·ªØ li·ªáu trong kho·∫£ng th·ªùi gian b·∫°n ch·ªçn.")
                    else:
                        vbt_freq = tf.upper().replace('M', 'T')
                        if vbt_freq == '1W': vbt_freq = 'W-MON'
                        portfolio = vbt.Portfolio.from_signals(
                            close=backtest_price, entries=backtest_entries, exits=backtest_exits,
                            freq=vbt_freq, init_cash=initial_cash, sl_stop=sl_pct / 100,
                            tp_stop=tp_pct / 100, fees=0.001
                        )
                        stats = portfolio.stats()
                        st.header("üìä K·∫øt qu·∫£ T·ªïng quan")
                        st.info(f"**Kho·∫£ng th·ªùi gian backtest:** {stats['Start'].strftime('%Y-%m-%d')} ƒë·∫øn {stats['End'].strftime('%Y-%m-%d')}")
                        st.subheader("C√°c ch·ªâ s·ªë Hi·ªáu su·∫•t")
                        col1, col2, col3, col4 = st.columns(4)
                        col1.metric("T·ªïng L·ª£i nhu·∫≠n [%]", f"{stats.get('Total Return [%]', 0):.2f}")
                        col2.metric("T·ª∑ l·ªá Th·∫Øng [%]", f"{stats.get('Win Rate [%]', 0):.2f}")
                        col3.metric("T·ª∑ l·ªá Sharpe", f"{stats.get('Sharpe Ratio', 0):.2f}")
                        col4.metric("S·ª•t gi·∫£m T·ªëi ƒëa [%]", f"{stats.get('Max Drawdown [%]', 0):.2f}")
                        st.divider()
                        st.subheader("Ph√¢n t√≠ch Chi ti·∫øt")
                        plot_col, stats_col = st.columns([2, 1])
                        with plot_col:
                            st.markdown("##### Bi·ªÉu ƒë·ªì V·ªën theo Th·ªùi gian")
                            fig = portfolio.plot()
                            st.plotly_chart(fig, use_container_width=True)
                        with stats_col:
                            st.markdown("##### Th·ªëng k√™ Chi ti·∫øt")
                            stats_display = stats.astype(str)
                            st.dataframe(stats_display)
                else:
                    st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ch·∫°y backtest.")